
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio - Orbito ++</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css">
    <link rel="stylesheet" href="css/style.css" />
    <link rel="icon" href="images/favicon.png" type="image/png">

</head>
<body>
<header>
    <nav class="navbar">
        <a href="index.html">Accueil</a>
        <a href="trace1.html">24h Info</a>
        <a href="trace2.html">Orbito++</a>
    </nav>
</header>

<main class="container">
    <h1>Orbito++</h1>
    <section class="trace">
        <div class="trace-content">
            <figure>
                <img src="images/Orbito_win.png" alt="Vérification de victoire Orbito" />
                <figcaption>Figure 3 : Vérification de victoire pour le jeu Orbito++</figcaption>
            </figure>
        </div>
        <div class="trace-text">

            <p>
                La Figure 3 donne un exemple de l'interface en mode texte du jeu "Orbito ++", développé dans le cadre d'un projet en équipe. Ce jeu est une réadaptation numérique du jeu de plateau Orbito, avec plusieurs améliorations et options de personnalisation. Contrairement au jeu original, cette implémentation permet de jouer sur un plateau 4x4 ou 6x6, de définir le sens de rotation de chaque anneaux, et de définir une longueur de ligne victorieuse de 4 ou 6 cases, selon les règles choisies en début de partie. Tout le projet a été fait en intégrant un framework (une bibliothèque externe) déjà existant, et adapté pour la création de jeu de plateau.<br><br>

                La figure illustre une partie très importante du code : la vérification de la condition de victoire. Dans l’exemple montré, le plateau utilisé est de taille 6x6, et la longueur de ligne nécessaire pour gagner est de 4. Le but de cette fonction est de parcourir tout le plateau pour détecter si une ligne (verticale, horizontale ou diagonale) satisfait la condition de victoire.<br><br>

                Ce problème est plus complexe qu’il n’y paraît, car il ne suffit pas de vérifier quelques lignes ou colonnes fixes : l’algorithme doit s’adapter dynamiquement à la taille du plateau, mais aussi à celle de la ligne victorieuse. Il doit donc itérer intelligemment sur toutes les positions de départ possibles, sans sortir du tableau ni manquer de combinaisons valides. Chaque case peut potentiellement être le début d’une ligne gagnante, et cela dans quatre directions différentes : droite (→), bas (↓), diagonale descendante (↘) et diagonale montante (↗).<br><br>

                Le principal défi de cet algorithme a été de généraliser la détection de victoire, sans codage en dur pour une taille spécifique. J’ai donc conçu une structure de boucles imbriquées et de conditions qui testent chaque direction possible à partir d’une case donnée.<br>
                Pour améliorer l'optimisation, j'ai ajouté une condition qui arrête la vérification de la ligne dès qu'elle est défini comme invalide (deux billes de couleur différente, ou une case vide)<br>
                À chaque itération, une variable compte le nombre de pions consécutifs identiques appartenant au même joueur. Si ce compteur atteint la taille de ligne attendue, la partie est considérée comme gagnée.<br>
                La partie difficile a été de faire la vérification pour une ligne de 4 sur un plateau 6x6. Dans cette situation, j'ai considéré le plateau 6x6 comme étant 9 plateaux 4x4 (représentation d'un en jaune), et de déplacer le "sous plateau" d'un cran (représentation en rouge) une fois que la vérification de celui ci est terminé, tout en ignorant les lignes déjà entièrement parcourus sur le sous plateau précédent.<br><br>

                Ce projet, m’a permis d’appliquer concrètement plusieurs concepts abordés en cours, notamment sur les structures de contrôle, les tests de validation (qui ont été vitaux pour essayer l’algorithme de validation), et la programmation orientée objet.
            </p>
        </div>
    </section>
</main>

<div class="footer-basic">
    <footer>
        <div class="social"><a href="mailto:aurelien.paillard@edu.univ-fcomte.fr"><i class="icon ion-email"></i></a><a href="https://github.com/AurelienP29"><i class="icon ion-social-github"></i></a></div>
        <p class="copyright">PAILLARD Aurélien © 2025</p>
    </footer>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
</body>
</html>